{ *************************************************************************** }
{                                                                             }
{ Kylix and Delphi Cross-Platform Visual Component Library                    }
{                                                                             }
{ Copyright (c) 2000, 2001 Borland Software Corporation                       }
{                                                                             }
{ This file may be distributed and/or modified under the terms of the GNU     }
{ General Public License (GPL) version 2 as published by the Free Software    }
{ Foundation and appearing at http://www.borland.com/kylix/gpl.html.          }
{                                                                             }
{ Licensees holding a valid Borland No-Nonsense License for this Software may }
{ use this file in accordance with such license, which appears in the file    }
{ license.txt that came with this Software.                                   }
{                                                                             }
{ *************************************************************************** }

{
  @abstract(The purpose of @name is to define
  @link(TSparsePointerArray) which acts like an array of pointers
  It provides constant
  time access to @link(TSparsePointerArray.Items).
  However, it uses less memory than an
  array for cases where many of the pointers are nil.)

  @name is modified from QGrids.pas to put
  @link(TSparsePointerArray) in the interface and to modify comments to be
  compatible with TPasDoc.
}

unit SparseArrayUnit;

interface

uses SysUtils;

type

  { Exception classes }

  {@abstract(@name is the type of exception generated by errors regarding
    sparse arrays.)}
  EStringSparseListError = class(Exception);

  { TSparsePointerArray class}

  { @longcode(#
    TSPAApply = function(TheIndex: Integer; TheItem: Pointer): Integer;
    #)

   Used by TSparseList.  Based on Sparse1Array, but has Pointer elements
    and Integer index, just like TPointerList/TList, and less indirection

     Apply function for the applicator:
          TheIndex        Index of item in array
          TheItem         Value of item (i.e pointer element) in section
          Returns: 0 if success, else error code. }
//  TSPAApply = function(TheIndex: Integer; TheItem: Pointer): Integer;
  TSPAApply = TFunc<NativeInt, Pointer, NativeInt>;

  { Enough for up to 12 bits of sec }
//  TSecDir = array[0..4095] of Pointer;
  TSecDir = array[0..65535] of Pointer;
  PSecDir = ^TSecDir;
//  PSecDir = array of Pointer;
  TSecDirType = PSecDir;

  TCustomData = Pointer;

  { Section size }
  TSPAQuantum = (SPASmall, SPALarge);

  {@abstract(@name acts like an array of pointers with constant
   time access to @link(TSparsePointerArray.Items).
   However, it uses less memory than an
   array for cases where many of the pointers are nil.)}
  TSparsePointerArray = class(TObject)
  private
    secDir: TSecDirType;
    slotsInDir: Cardinal;
    indexMask, secShift: Word;
    FHighBound: Integer;
    FSectionSize: Word;
    cachedIndex: Integer;
    cachedValue: TCustomData;
    { Return item[i], nil if slot outside defined section. }
    function GetAt(Index: Integer): TCustomData;
    { Return address of item[i], creating slot if necessary. }
    function MakeAt(Index: Integer): PPointer;
    { Store item at item[i], creating slot if necessary. }
    procedure PutAt(Index: Integer; Item: TCustomData);
  public
    constructor Create(Quantum: TSPAQuantum);
    destructor Destroy; override;

    { Traverse SPA, calling apply function for each defined non-nil
      item.  The traversal terminates if the apply function returns
      a value other than 0.
      NOTE: must be static method so that we can take its address in
      TSparseList.ForAll

      See @link(TSPAApply)}
    function ForAll(ApplyFunction: TSPAApply): Integer;

    { Ratchet down HighBound after a deletion }
    procedure ResetHighBound;

    property HighBound: Integer read FHighBound;
    property SectionSize: Word read FSectionSize;
    property Items[Index: Integer]: TCustomData read GetAt write PutAt; default;
  end;

implementation

uses Windows;

resourcestring
  StrIndexOutOfBounds = 'Index out of bounds: %d';

const
  SPAIndexMask: array[TSPAQuantum] of Byte = (15, 255);
  SPASecShift: array[TSPAQuantum] of Byte = (4, 8);

  { Expand Section Directory to cover at least `newSlots' slots.
    Returns: Possibly updated pointer to the Section Directory. }

function ExpandDir(secDir: PSecDir; var slotsInDir: Cardinal;
  newSlots: Word): PSecDir;
begin
  Result := secDir;
  ReallocMem(Result, newSlots * SizeOf(Pointer));
  FillChar(Result^[slotsInDir], (newSlots - slotsInDir) * SizeOf(Pointer), 0);
  slotsInDir := newSlots;
end;

{ Allocate a section and set all its items to nil. Returns: Pointer to start of
  section. }

function MakeSec(SecIndex: Integer; SectionSize: Word): Pointer;
var
  SecP: Pointer;
  Size: Word;
begin
  Size := SectionSize * SizeOf(Pointer);
  GetMem(secP, size);
  FillChar(secP^, size, 0);
  MakeSec := SecP
end;

{ TSparsePointerArray }

constructor TSparsePointerArray.Create(Quantum: TSPAQuantum);
begin
  SecDir := nil;
  SlotsInDir := 0;
  FHighBound := -1;
  FSectionSize := Word(SPAIndexMask[Quantum]) + 1;
  IndexMask := Word(SPAIndexMask[Quantum]);
  SecShift := Word(SPASecShift[Quantum]);
  CachedIndex := -1
end;

destructor TSparsePointerArray.Destroy;
var
  i: Cardinal;
  size: Word;
begin
  { Scan section directory and free each section that exists. }
  i := 0;
  size := FSectionSize * SizeOf(Pointer);
  while i < slotsInDir do
  begin
    if secDir^[i] <> nil then
      FreeMem(secDir^[i], size);
    Inc(i)
  end;

  { Free section directory. }
  if secDir <> nil then
    FreeMem(secDir, slotsInDir * SizeOf(Pointer));
end;

function TSparsePointerArray.ForAll(ApplyFunction: TSPAApply): Integer;
var
  itemP: PByte; { Pointer to item in section }
  item: Pointer;
  i {, callerBP}: Cardinal;
  j, index: Integer;
begin
  { Scan section directory and scan each section that exists,
    calling the apply function for each non-nil item.   }
//    The apply function must be a far local function in the scope of
//    the procedure P calling ForAll.  The trick of setting up the stack
//    frame (taken from TurboVision's TCollection.ForEach) allows the
//    apply function access to P's arguments and local variables and,
//    if P is a method, the instance variables and methods of P's class }
  Result := 0;
  i := 0;
//  asm
//    mov   eax,[ebp]                     { Set up stack frame for local }
//    mov   callerBP,eax
//  end;
  while (i < slotsInDir) and (Result = 0) do
  begin
    itemP := secDir^[i];
    if itemP <> nil then
    begin
      j := 0;
      index := i shl SecShift;
      while (j < FSectionSize) and (Result = 0) do
      begin
        item := PPointer(itemP)^;
        if item <> nil then
        begin
          { ret := ApplyFunction(index, item.Ptr); }
          result := ApplyFunction(index, item);
//          asm
//            mov   eax,index
//            mov   edx,item
//            push  callerBP
//            call  ApplyFunction
//            pop   ecx
//            mov   @Result,eax
//          end;
        end;
        Inc(itemP, SizeOf(Pointer));
        Inc(j);
        Inc(index)
      end
    end;
    Inc(i)
  end;
end;

function TSparsePointerArray.GetAt(Index: Integer): TCustomData;
var
  byteP: PByte;
  secIndex: Cardinal;
begin
  { Index into Section Directory using high order part of
    index.  Get pointer to Section. If not null, index into
    Section using low order part of index. }
  Assert(Index >= 0);
  if Index = cachedIndex then
    Result := cachedValue
  else
  begin
    secIndex := Index shr secShift;
    if secIndex >= slotsInDir then
      byteP := nil
    else
    begin
      byteP := secDir^[secIndex];
      if byteP <> nil then
      begin
        Inc(byteP, (Index and indexMask) * SizeOf(Pointer));
      end
    end;
    if byteP = nil then
      Result := nil
    else
      Result := PPointer(byteP)^;
    cachedIndex := Index;
    cachedValue := Result
  end
end;

function TSparsePointerArray.MakeAt(Index: Integer): PPointer;
var
  dirP: PSecDir;
  p: Pointer;
  byteP: PByte;
  secIndex: Word;
begin
  if (Index shr secShift >= High(Word)) then
    raise EStringSparseListError.Create(Format(StrIndexOutOfBounds, [Index]));
  { Expand Section Directory if necessary. }
  secIndex := Index shr secShift; { Unsigned shift }
  if secIndex >= slotsInDir then
    dirP := expandDir(secDir, slotsInDir, secIndex + 1)
  else
    dirP := secDir;

  { Index into Section Directory using high order part of
    index.  Get pointer to Section. If null, create new
    Section.  Index into Section using low order part of index. }
  secDir := dirP;
  p := dirP^[secIndex];
  if p = nil then
  begin
    p := makeSec(secIndex, FSectionSize);
    dirP^[secIndex] := p
  end;
  byteP := p;
  Inc(byteP, (Index and indexMask) * SizeOf(Pointer));
  if Index > FHighBound then
    FHighBound := Index;
  Result := PPointer(byteP);
  cachedIndex := -1
end;

procedure TSparsePointerArray.PutAt(Index: Integer; Item: TCustomData);
begin
  if (Item <> nil) or (GetAt(Index) <> nil) then
  begin
    MakeAt(Index)^ := Item;
    if Item = nil then
      ResetHighBound
  end
end;

procedure TSparsePointerArray.ResetHighBound;
var
  NewHighBound: Integer;

//  function Detector(TheIndex: Integer; TheItem: Pointer): Integer; far;
//  begin
//    if TheIndex > FHighBound then
//      Result := 1
//    else
//    begin
//      Result := 0;
//      if TheItem <> nil then
//        NewHighBound := TheIndex
//    end
//  end;

begin
  NewHighBound := -1;
  ForAll(
    function (TheIndex: NativeInt; TheItem: Pointer): NativeInt
    begin
      if TheIndex > FHighBound then
        Result := 1
      else
      begin
        Result := 0;
        if TheItem <> nil then
          NewHighBound := TheIndex
      end
  end);
  FHighBound := NewHighBound
end;

end.

