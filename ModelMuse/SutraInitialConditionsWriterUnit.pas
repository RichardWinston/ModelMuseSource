unit SutraInitialConditionsWriterUnit;

interface

uses
  Windows, CustomModflowWriterUnit, SysUtils, DataSetUnit, PhastModelUnit,
  Generics.Collections, Classes, SutraOptionsUnit;

type
  TDataValue = class(TObject)
    Number: integer;
    Value: double;
  end;

  TDataValueList = TObjectList<TDataValue>;

  TSutraInitialConditionsWriter = class(TCustomFileWriter)
  private
    FRestartFile: TStreamReader;
    FOptions: TSutraOptions;
    FLimit: Integer;
    procedure WriteDataArray(DataArray: TDataArray);
    procedure WriteDataSet0;
    procedure WriteDataSet1;
    procedure WriteDataSet2;
    procedure WriteDataSet3;
  protected
    class function Extension: string; override;
  public
    Constructor Create(AModel: TCustomModel); reintroduce;
    procedure WriteFile(FileName: string);
  end;

implementation

uses
  GoPhastTypes, SutraMeshUnit, Generics.Defaults,
  SutraFileWriterUnit, IOUtils, Dialogs;

resourcestring
  StrTheRestartFileS = 'The restart file "%s" does not exist.';
  StrTheEndOfTheResta = 'The end of the restart file, %0:s, was reached before' +
  ' reading all the data required for data set %1:d of the initial conditions f' +
  'ile.';



{ TSutraInitialConditionsWriter }

constructor TSutraInitialConditionsWriter.Create(AModel: TCustomModel);
begin
  inherited Create(AModel, etExport);
end;

class function TSutraInitialConditionsWriter.Extension: string;
begin
  Assert(False);
end;

procedure TSutraInitialConditionsWriter.WriteDataArray(DataArray: TDataArray);
var
  List: TDataValueList;
  index: Integer;
  NodeIndex: Integer;
  Mesh2D: TSutraMesh2D;
  LayerIndex: Integer;
  Mesh3D: TSutraMesh3D;
  Node3D: TSutraNode3D;
  DataValue: TDataValue;
begin
  Assert(DataArray.EvaluatedAt = eaNodes);
  DataArray.Initialize;
  if DataArray.IsUniform = iuTrue then
  begin
    WriteString('''UNIFORM''');
    NewLine;
    WriteFloat(DataArray.UniformRealValue);
    NewLine;
  end
  else
  begin
    WriteString('''NONUNIFORM''');
    NewLine;
    List := TDataValueList.Create;
    try

      case Model.SutraMesh.MeshType of
        mt2D, mtProfile:
          begin
            Mesh2D := Model.SutraMesh.Mesh2D;
            for NodeIndex := 0 to Mesh2D.Nodes.Count - 1 do
            begin
              DataValue := TDataValue.Create;
              List.Add(DataValue);
              DataValue.Value := DataArray.RealData[0,0,NodeIndex];
              DataValue.Number := Mesh2D.Nodes[NodeIndex].Number;
            end;
          end;
        mt3D:
          begin
            Mesh3D := Model.SutraMesh;
            Mesh2D := Mesh3D.Mesh2D;
            for LayerIndex := 0 to Mesh3D.LayerCount do
            begin
              for NodeIndex := 0 to Mesh2D.Nodes.Count - 1 do
              begin
                Node3D := Mesh3D.NodeArray[LayerIndex, NodeIndex];
                if Node3D.Active then
                begin
                  DataValue := TDataValue.Create;
                  List.Add(DataValue);
                  DataValue.Value := DataArray.RealData[LayerIndex,0,NodeIndex];
                  DataValue.Number := Node3D.Number;
                end;
              end;
            end;
          end;
        else
          Assert(False);
      end;
      List.Sort(TComparer<TDataValue>.Construct(
        function (const L, R: TDataValue): integer
        begin
          result := L.Number - R.Number;
        end));
      for index := 0 to List.Count - 1 do
      begin
        DataValue := List[index];
        WriteFloat(DataValue.Value);
        if ((index + 1) mod 10) = 0 then
        begin
          NewLine;
        end;
      end;
      if (List.Count  mod 10) <> 0 then
      begin
        NewLine;
      end;
    finally
      List.Free;
    end;
  end;

  Model.DataArrayManager.AddDataSetToCache(DataArray);
  Model.DataArrayManager.CacheDataArrays;
end;

procedure TSutraInitialConditionsWriter.WriteDataSet0;
begin
  WriteCommentLine(File_Comment('SUTRA initial conditions file'));
end;

procedure TSutraInitialConditionsWriter.WriteDataSet1;
var
  TICS: double;
begin
  WriteCommentLine('Data set 1');

  TICS := (Model as TPhastModel).SutraTimeOptions.InitialTime;
  WriteFloat(TICS);
  NewLine;
end;

procedure TSutraInitialConditionsWriter.WriteDataSet2;
var
  InitialPressure: TDataArray;
  index: Integer;
  ALine: string;
begin
  WriteCommentLine('Data set 2');

  if FOptions.ReadStart in [rsPressure, rsBoth] then
  begin
    Assert(Assigned(FRestartFile));
    ALine := FRestartFile.ReadLine;
    WriteString(ALine);
    NewLine;
    for index := 0 to FLimit - 1 do
    begin
      ALine := FRestartFile.ReadLine;
      WriteString(ALine);
      NewLine;
      if FRestartFile.EndOfStream then
      begin
        Beep;
        MessageDlg(Format(StrTheEndOfTheResta,
          [FOptions.FullReadStartRestartFileName, 2]),
          mtError, [mbOK], 0);
        break;
      end;
    end;
  end
  else
  begin
    InitialPressure := nil;
    case (Model as TPhastModel).SutraOptions.TransportChoice of
      tcSolute, tcEnergy:
        InitialPressure := Model.DataArrayManager.GetDataSetByName(KInitialPressure);
      tcSoluteHead:
        InitialPressure := Model.DataArrayManager.GetDataSetByName(rsInitial_Head);
      else
        Assert(False);
    end;

    WriteDataArray(InitialPressure);

  end;
end;

procedure TSutraInitialConditionsWriter.WriteDataSet3;
var
  InitialU: TDataArray;
  index: Integer;
  ALine: string;
begin
  WriteCommentLine('Data set 3');

  if FOptions.ReadStart in [rsU, rsBoth] then
  begin
    Assert(Assigned(FRestartFile));
    if FOptions.ReadStart = rsU then
    begin
      FRestartFile.ReadLine;
      for index := 0 to FLimit - 1 do
      begin
        FRestartFile.ReadLine;
      end;
    end;
    ALine := FRestartFile.ReadLine;
    WriteString(ALine);
    NewLine;
    for index := 0 to FLimit - 1 do
    begin
      ALine := FRestartFile.ReadLine;
      WriteString(ALine);
      NewLine;
      if FRestartFile.EndOfStream then
      begin
        Beep;
        MessageDlg(Format(StrTheEndOfTheResta,
          [FOptions.FullReadStartRestartFileName, 3]),
          mtError, [mbOK], 0);
        break;
      end;
    end;
  end
  else
  begin
    InitialU := nil;
    case Model.SutraOptions.TransportChoice of
      tcSolute, tcSoluteHead: InitialU := Model.DataArrayManager.GetDataSetByName(
        KInitialConcentration);
      tcEnergy: InitialU := Model.DataArrayManager.GetDataSetByName(
        KInitialTemperature);
      else
        Assert(False);
    end;
    WriteDataArray(InitialU);
  end;
end;

procedure TSutraInitialConditionsWriter.WriteFile(FileName: string);
var
  ErrorMessage: string;
  Mesh: TSutraMesh3D;
  NodeCount: Integer;
begin
  FOptions := Model.SutraOptions;
  if (FOptions.StartType = stWarm) and (FOptions.FullRestartFileName <> '') then
  begin
    SutraFileWriter.AddFile(sftIcs, FOptions.FullRestartFileName);
  end
  else
  begin
    FRestartFile := nil;
    try
      if FOptions.ReadStart in [rsPressure, rsU, rsBoth] then
      begin
         Model.AddModelInputFile(FOptions.FullReadStartRestartFileName);
         if not TFile.Exists(FOptions.FullReadStartRestartFileName) then
         begin
           Beep;
           ErrorMessage := Format(StrTheRestartFileS,
             [FOptions.FullReadStartRestartFileName]);
           MessageDlg(ErrorMessage, mtError, [mbOK], 0);
           Exit;
         end
         else
         begin
           FRestartFile := TFile.OpenText(FOptions.FullReadStartRestartFileName);
           FRestartFile.ReadLine;
           Mesh := Model.Mesh;
           if Mesh.MeshType = mt3D then
           begin
             NodeCount := Mesh.ActiveNodeCount;
           end
           else
           begin
             NodeCount := Mesh.Mesh2D.Nodes.Count;
           end;
           FLimit := (NodeCount - 1) div 4 + 1;
         end;
      end;


      FileName := ChangeFileExt(FileName, '.ics');
      OpenFile(FileName);
      try
        WriteDataSet0;
        WriteDataSet1;
        WriteDataSet2;
        WriteDataSet3;
        SutraFileWriter.AddFile(sftIcs, FileName);
      finally
        CloseFile;
      end;
    finally
      FRestartFile.Free;
    end;
  end;

end;

end.
